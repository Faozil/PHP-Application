name: Deploy PHP Application

on:
  push:
    branches: [ main ]
  
env:
  AWS_REGION: eu-west-2
  STACK_NAME: php-app
  DOCKER_IMAGE_TAG: ${{ github.sha }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-
    
    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: false
        tags: php-app:${{ env.DOCKER_IMAGE_TAG }}
        load: true
        cache-from: type=local,src=/tmp/.buildx-cache
        cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
    
    - name: Move cache
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache
    
    - name: Create Docker network
      run: docker network create test-network
    
    - name: Start MySQL container
      run: |
        docker run -d \
          --name mysql-container \
          --network test-network \
          --network-alias mysql \
          -e MYSQL_ROOT_PASSWORD=${{ secrets.TEST_DB_PASSWORD }} \
          -e MYSQL_DATABASE=testdb \
          -e MYSQL_USER=testuser \
          -e MYSQL_PASSWORD=${{ secrets.TEST_DB_PASSWORD }} \
          -p 3306:3306 \
          --health-cmd="mysqladmin ping -h localhost --silent" \
          --health-interval=10s \
          --health-timeout=5s \
          --health-retries=10 \
          mysql:8.0
    
    - name: Wait for MySQL to be ready
      run: |
        echo "Waiting for MySQL to be ready..."
        timeout 120 bash -c 'until docker exec mysql-container mysqladmin ping -h localhost --silent; do 
          echo "MySQL is not ready yet..."
          sleep 3
        done'
        echo "MySQL is ready"
        
        # Additional verification - check if MySQL is accepting connections
        docker exec mysql-container mysql -u testuser -p${{ secrets.TEST_DB_PASSWORD }} -e "SELECT 1;" testdb
        echo "MySQL connection verified"
    
    - name: Run PHP application container
      run: |
        docker run -d --name php-app --network test-network -p 8080:80 \
          -e DB_HOST=mysql \
          -e DB_USERNAME=testuser \
          -e DB_PASSWORD=${{ secrets.TEST_DB_PASSWORD }} \
          -e DB_NAME=testdb \
          -e DB_PORT=3306 \
          -e APP_ENV=testing \
          php-app:${{ env.DOCKER_IMAGE_TAG }}

        docker ps --filter name=php-app
        docker ps --filter name=mysql-container
    
    - name: Check container logs
      run: |
        echo "=== PHP Application Logs ==="
        docker logs php-app || echo "No logs yet"
        echo "=== MySQL Logs ==="
        docker logs mysql-container | tail -10 || echo "No MySQL logs"
    
    - name: Test network connectivity
      run: |
        echo "Testing network connectivity..."
        
        # Check if containers are on the same network
        echo "=== Network inspection ==="
        docker network inspect test-network
        
        # Test basic connectivity using ping instead of curl (MySQL port isn't HTTP)
        docker exec php-app ping -c 3 mysql || echo "Cannot ping mysql"
        
        # Check if PHP container can resolve mysql hostname
        docker exec php-app nslookup mysql || echo "Cannot resolve mysql hostname"
        docker exec php-app getent hosts mysql || echo "Cannot resolve mysql hostname via hosts"
        
        # Test MySQL connection from PHP container
        docker exec php-app php -r "
        try {
          \$pdo = new PDO('mysql:host=mysql;port=3306;dbname=testdb', 'testuser', '${{ secrets.TEST_DB_PASSWORD }}');
          echo 'Database connection successful\n';
          \$result = \$pdo->query('SELECT 1 as test');
          echo 'Query test: ' . \$result->fetch()['test'] . \"\n\";
        } catch (Exception \$e) {
          echo 'Database connection failed: ' . \$e->getMessage() . \"\n\";
        }
        " || echo "PHP database test failed"

    - name: Wait for application to be ready
      run: |
        echo "Waiting for application to respond..."
        timeout 180 bash -c 'until curl -s http://localhost:8080/ | grep -q "Simple PHP Application"; do 
          echo "App not ready yet. Checking logs..."
          docker logs php-app | tail -5
          echo "Checking MySQL status..."
          docker exec mysql-container mysqladmin ping -h localhost --silent && echo "MySQL is running" || echo "MySQL not responding"
          sleep 10
        done'
        echo "Application is responding"
    
    - name: Set up Python for testing
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install Python test dependencies
      run: |
        pip install -r tests/requirements.txt
    
    - name: Download latest ChromeDriver
      run: |
        wget "https://storage.googleapis.com/chrome-for-testing-public/138.0.7153.0/linux64/chromedriver-linux64.zip"
        unzip chromedriver-linux64.zip
        chmod +x chromedriver-linux64/chromedriver
        sudo mv chromedriver-linux64/chromedriver /usr/local/bin/

    - name: Run application tests
      env:
        APP_URL: http://localhost:8080
        DB_HOST: localhost
        DB_PORT: 3306
        DB_NAME: testdb
        DB_USERNAME: testuser
        DB_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
        DISPLAY: :99
      run: |
        # Start virtual display for headless Chrome
        sudo apt-get update -qq
        sudo apt-get install -y xvfb
        export DISPLAY=:99
        Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
        sleep 3

        python -m pytest tests/ -v --tb=short
    
    - name: Run basic smoke tests
      run: |
        echo "Testing basic connectivity..."
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ || echo "000")
        echo "HTTP response code: $HTTP_CODE"

        echo "Testing application response..."
        RESPONSE=$(curl -s http://localhost:8080/ || echo "FAILED")
        echo "Response preview:"
        echo "$RESPONSE" | head -20
        
        # Check for successful database connection in response
        if echo "$RESPONSE" | grep -q "Database connection successful\|success"; then
          echo "✓ Database connection appears successful"
        else
          echo "✗ Database connection appears to have failed"
          echo "=== Final container logs ==="
          docker logs php-app
          docker logs mysql-container | tail -20
        fi
        
        # Check if application loads without critical errors
        if echo "$RESPONSE" | grep -q "Simple PHP Application"; then
          echo "✓ Application loaded successfully"
        else
          echo "✗ Application failed to load properly"
          exit 1
        fi
    
    - name: Cleanup containers
      if: always()
      run: |
        docker stop php-app mysql-container || true
        docker rm php-app mysql-container || true
        docker network rm test-network || true
        
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        role-duration-seconds: 3600
    
    - name: Validate CloudFormation template
      run: |
        aws cloudformation validate-template \
          --template-body file://infrastructure/cloudformation.yaml \
          --region ${{ env.AWS_REGION }}
    
    - name: Check if stack exists
      id: check-stack
      run: |
        if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "stack-exists=true" >> $GITHUB_OUTPUT
          echo "Stack exists, will update"
        else
          echo "stack-exists=false" >> $GITHUB_OUTPUT
          echo "Stack does not exist, will create"
        fi
    
    - name: Deploy CloudFormation stack
      id: deploy-stack
      run: |
        aws cloudformation deploy \
          --template-file infrastructure/cloudformation.yaml \
          --stack-name ${{ env.STACK_NAME }} \
          --parameter-overrides \
            KeyPairName=${{ secrets.KEY_PAIR_NAME }} \
            DBUsername=${{ secrets.DB_USERNAME }} \
            DBPassword=${{ secrets.DB_PASSWORD }} \
            Environment=production \
            ImageTag=${{ env.DOCKER_IMAGE_TAG }} \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region ${{ env.AWS_REGION }} \
          --no-fail-on-empty-changeset
    
    - name: Wait for stack deployment
      run: |
        if [ "${{ steps.check-stack.outputs.stack-exists }}" = "true" ]; then
          echo "Waiting for stack update to complete..."
          aws cloudformation wait stack-update-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} || \
          aws cloudformation wait stack-update-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
        else
          echo "Waiting for stack creation to complete..."
          aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
        fi
    
    - name: Get deployment outputs
      id: get-outputs
      run: |
        STACK_OUTPUTS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs')
        
        LOAD_BALANCER_DNS=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="LoadBalancerDNS") | .OutputValue')
        APP_URL="https://${LOAD_BALANCER_DNS}"
        
        echo "app-url=${APP_URL}" >> $GITHUB_OUTPUT
        echo "load-balancer-dns=${LOAD_BALANCER_DNS}" >> $GITHUB_OUTPUT
        
        echo "Application deployed to: ${APP_URL}"
    
    - name: Wait for application to be accessible
      run: |
        echo "Waiting for application to be accessible at ${{ steps.get-outputs.outputs.app-url }}"
        timeout 600 bash -c 'until curl -k -s "${{ steps.get-outputs.outputs.app-url }}/health.php" | grep -q "OK\|healthy"; do 
          echo "Waiting for app to be accessible..."
          sleep 10
        done'
        echo "Application is accessible"
    
    - name: Run post-deployment integration tests
      env:
        APP_URL: ${{ steps.get-outputs.outputs.app-url }}
      run: |
        # Set up Python for integration tests
        pip install -r tests/requirements.txt
        
        # Run integration tests against deployed application
        python -m pytest tests/ -v --tb=short
    
    - name: Update deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "Deployment completed successfully"
          echo "Application URL: ${{ steps.get-outputs.outputs.app-url }}"
          echo "Load Balancer DNS: ${{ steps.get-outputs.outputs.load-balancer-dns }}"
        else
          echo "Deployment failed"
        fi
