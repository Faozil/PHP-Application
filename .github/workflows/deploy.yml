name: Deploy PHP Application

on:
  push:
    branches: [ main ]
  
env:
  AWS_REGION: eu-west-2
  STACK_NAME: php-app
  DOCKER_IMAGE_TAG: ${{ github.sha }}

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          MYSQL_DATABASE: testdb
          MYSQL_USER: testuser
          MYSQL_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping -h localhost" --health-interval=10s --health-timeout=5s --health-retries=5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-
    
    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: false
        tags: php-app:${{ env.DOCKER_IMAGE_TAG }}
        load: true
        cache-from: type=local,src=/tmp/.buildx-cache
        cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
    
    - name: Move cache
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache
    
    - name: Create Docker network
      run: docker network create test-network
    
    - name: Wait for MySQL to be ready
      run: |
        timeout 60 bash -c 'until docker exec $(docker ps -q --filter ancestor=mysql:8.0) mysqladmin ping -h localhost --silent; do sleep 2; done'
    
    - name: Run PHP application container
      run: |
        docker run -d --name php-app --network test-network -p 8080:80 \
          -e DB_HOST=mysql \
          -e DB_USERNAME=testuser \
          -e DB_PASSWORD=${{ secrets.TEST_DB_PASSWORD }} \
          -e DB_NAME=testdb \
          -e DB_PORT=3306 \
          -e APP_ENV=testing \
          php-app:${{ env.DOCKER_IMAGE_TAG }}
    
    - name: Connect MySQL to test network
      run: docker network connect test-network $(docker ps -q --filter ancestor=mysql:8.0)
    
    - name: Wait for application to be ready
      run: |
        timeout 180 bash -c 'until curl -s http://localhost:8080/health.php | grep -q "OK\|healthy"; do 
          echo "Waiting for app to be ready..."
          sleep 5
        done'
    
    - name: Set up Python for testing
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install Python test dependencies
      run: |
        pip install -r tests/requirements.txt
    
    - name: Run application tests
      env:
        APP_URL: http://localhost:8080
        DB_HOST: localhost
        DB_PORT: 3306
        DB_NAME: testdb
        DB_USERNAME: testuser
        DB_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
      run: |
        python -m pytest tests/ -v --tb=short
    
    - name: Run basic smoke tests
      run: |
        curl -f http://localhost:8080/health.php || exit 1
        echo "Health check passed"
        
        # Check if app responds to main endpoint
        curl -f http://localhost:8080/ || echo "This is not ready yet"
    
    - name: Cleanup containers
      if: always()
      run: |
        docker stop php-app || true
        docker rm php-app || true
        docker network rm test-network || true

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        role-duration-seconds: 3600
    
    - name: Validate CloudFormation template
      run: |
        aws cloudformation validate-template \
          --template-body file://infrastructure/cloudformation.yaml \
          --region ${{ env.AWS_REGION }}
    
    - name: Check if stack exists
      id: check-stack
      run: |
        if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "stack-exists=true" >> $GITHUB_OUTPUT
          echo "Stack exists, will update"
        else
          echo "stack-exists=false" >> $GITHUB_OUTPUT
          echo "Stack does not exist, will create"
        fi
    
    - name: Deploy CloudFormation stack
      id: deploy-stack
      run: |
        aws cloudformation deploy \
          --template-file infrastructure/cloudformation.yaml \
          --stack-name ${{ env.STACK_NAME }} \
          --parameter-overrides \
            KeyPairName=${{ secrets.KEY_PAIR_NAME }} \
            DBUsername=${{ secrets.DB_USERNAME }} \
            DBPassword=${{ secrets.DB_PASSWORD }} \
            Environment=production \
            ImageTag=${{ env.DOCKER_IMAGE_TAG }} \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region ${{ env.AWS_REGION }} \
          --no-fail-on-empty-changeset
    
    - name: Wait for stack deployment
      run: |
        if [ "${{ steps.check-stack.outputs.stack-exists }}" = "true" ]; then
          echo "Waiting for stack update to complete..."
          aws cloudformation wait stack-update-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} || \
          aws cloudformation wait stack-update-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
        else
          echo "Waiting for stack creation to complete..."
          aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
        fi
    
    - name: Get deployment outputs
      id: get-outputs
      run: |
        STACK_OUTPUTS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs')
        
        LOAD_BALANCER_DNS=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="LoadBalancerDNS") | .OutputValue')
        APP_URL="https://${LOAD_BALANCER_DNS}"
        
        echo "app-url=${APP_URL}" >> $GITHUB_OUTPUT
        echo "load-balancer-dns=${LOAD_BALANCER_DNS}" >> $GITHUB_OUTPUT
        
        echo "Application deployed to: ${APP_URL}"
    
    - name: Wait for application to be accessible
      run: |
        echo "Waiting for application to be accessible at ${{ steps.get-outputs.outputs.app-url }}"
        timeout 600 bash -c 'until curl -k -s "${{ steps.get-outputs.outputs.app-url }}/health.php" | grep -q "OK\|healthy"; do 
          echo "Waiting for app to be accessible..."
          sleep 10
        done'
        echo "Application is accessible"
    
    - name: Run post-deployment integration tests
      env:
        APP_URL: ${{ steps.get-outputs.outputs.app-url }}
      run: |
        # Set up Python for integration tests
        pip install -r tests/requirements.txt
        
        # Run integration tests against deployed application
        python -m pytest tests/ -v --tb=short
    
    - name: Update deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "Deployment completed successfully"
          echo "Application URL: ${{ steps.get-outputs.outputs.app-url }}"
          echo "Load Balancer DNS: ${{ steps.get-outputs.outputs.load-balancer-dns }}"
        else
          echo "Deployment failed"
        fi
