name: Deploy PHP Application

on:
  push:
    branches: [ main ]
  
env:
  AWS_REGION: eu-west-2
  STACK_NAME: php-app
  DOCKER_IMAGE_TAG: ${{ github.sha }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-
    
    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: false
        tags: php-app:${{ env.DOCKER_IMAGE_TAG }}
        load: true
        cache-from: type=local,src=/tmp/.buildx-cache
        cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
    
    - name: Move cache
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache
    
    - name: Start test environment
      run: |
        # Create network and start containers
        docker network create test-network
        
        # Start MySQL with health check
        docker run -d \
          --name mysql-container \
          --network test-network \
          --network-alias mysql \
          -e MYSQL_ROOT_PASSWORD=${{ secrets.TEST_DB_PASSWORD }} \
          -e MYSQL_DATABASE=testdb \
          -e MYSQL_USER=testuser \
          -e MYSQL_PASSWORD=${{ secrets.TEST_DB_PASSWORD }} \
          -p 3306:3306 \
          --health-cmd="mysqladmin ping -h localhost --silent" \
          --health-interval=5s \
          --health-timeout=3s \
          --health-retries=10 \
          mysql:8.0
        
        # Wait for MySQL to be ready
        echo "Waiting for MySQL to be ready..."
        timeout 60 bash -c 'until docker exec mysql-container mysqladmin ping -h localhost --silent; do sleep 2; done'
        
        # Start PHP application
        docker run -d --name php-app --network test-network -p 8080:80 \
          -e DB_HOST=mysql \
          -e DB_USERNAME=testuser \
          -e DB_PASSWORD=${{ secrets.TEST_DB_PASSWORD }} \
          -e DB_NAME=testdb \
          -e DB_PORT=3306 \
          -e APP_ENV=testing \
          php-app:${{ env.DOCKER_IMAGE_TAG }}
    
    - name: Wait for application to be ready
      run: |
        echo "Waiting for application to respond..."
        timeout 60 bash -c 'until curl -s http://localhost:8080/ | grep -q "Simple PHP Application"; do sleep 5; done'
        echo "Application is ready"
    
    - name: Set up test environment
      run: |
        # Install Python dependencies
        pip install -r tests/requirements.txt
        
        # Download ChromeDriver
        wget -q "https://storage.googleapis.com/chrome-for-testing-public/138.0.7153.0/linux64/chromedriver-linux64.zip"
        unzip -q chromedriver-linux64.zip
        chmod +x chromedriver-linux64/chromedriver
        sudo mv chromedriver-linux64/chromedriver /usr/local/bin/
        
        # Set up virtual display
        sudo apt-get update -qq
        sudo apt-get install -y xvfb
        export DISPLAY=:99
        Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
        sleep 2

    - name: Run tests
      env:
        APP_URL: http://localhost:8080
        DB_HOST: localhost
        DB_PORT: 3306
        DB_NAME: testdb
        DB_USERNAME: testuser
        DB_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
        DISPLAY: :99
      run: |
        # Run application tests
        python -m pytest tests/ -v --tb=short
        
        # Run basic smoke tests
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/)
        echo "HTTP response code: $HTTP_CODE"
        
        if [ "$HTTP_CODE" != "200" ]; then
          echo "Application health check failed"
          docker logs php-app
          exit 1
        fi
        
        echo "All tests passed successfully"
    
    - name: Cleanup test environment
      if: always()
      run: |
        docker stop php-app mysql-container || true
        docker rm php-app mysql-container || true
        docker network rm test-network || true

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        role-duration-seconds: 3600

    - name: Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v2

    - name: Check stack status and handle failures
      id: stack-check
      run: |
        if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].StackStatus' --output text)
          
          echo "stack-exists=true" >> $GITHUB_OUTPUT
          echo "Stack status: $STACK_STATUS"
          
          # Handle failed states
          if [[ "$STACK_STATUS" == *"ROLLBACK"* || "$STACK_STATUS" == *"FAILED"* ]]; then
            echo "Deleting failed stack..."
            aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }} --region ${{ env.AWS_REGION }}
            aws cloudformation wait stack-delete-complete --stack-name ${{ env.STACK_NAME }} --region ${{ env.AWS_REGION }}
            echo "stack-exists=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "stack-exists=false" >> $GITHUB_OUTPUT
          echo "Stack does not exist"
        fi

    - name: Deploy CloudFormation stack
      run: |
        echo "Deploying CloudFormation stack..."
        
        aws cloudformation validate-template \
          --template-body file://infrastructure/cloudformation.yaml \
          --region ${{ env.AWS_REGION }}
        
        aws cloudformation deploy \
          --template-file infrastructure/cloudformation.yaml \
          --stack-name ${{ env.STACK_NAME }} \
          --parameter-overrides \
            KeyPairName=${{ secrets.KEY_PAIR_NAME }} \
            DBUsername=${{ secrets.DB_USERNAME }} \
            DBPassword=${{ secrets.DB_PASSWORD }} \
            ImageTag=${{ env.DOCKER_IMAGE_TAG }} \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region ${{ env.AWS_REGION }} \
          --no-fail-on-empty-changeset

    - name: Get deployment outputs
      id: outputs
      run: |
        STACK_OUTPUTS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs')
        
        ECR_URI=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="ECRRepositoryUri") | .OutputValue')
        LOAD_BALANCER_DNS=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="LoadBalancerDNS") | .OutputValue')
        DATABASE_ENDPOINT=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="DatabaseEndpoint") | .OutputValue')
        
        echo "ecr-uri=${ECR_URI}" >> $GITHUB_OUTPUT
        echo "app-url=http://${LOAD_BALANCER_DNS}" >> $GITHUB_OUTPUT
        echo "database-endpoint=${DATABASE_ENDPOINT}" >> $GITHUB_OUTPUT
        
        echo "ECR URI: ${ECR_URI}"
        echo "Application URL: http://${LOAD_BALANCER_DNS}"

    - name: Build and push Docker image
      run: |
        ECR_URI="${{ steps.outputs.outputs.ecr-uri }}"
        
        echo "Building and pushing to: $ECR_URI"
        
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin $ECR_URI
        
        docker build -f Dockerfile -t $ECR_URI:${{ env.DOCKER_IMAGE_TAG }} .
        docker push $ECR_URI:${{ env.DOCKER_IMAGE_TAG }}
        
        echo "Image pushed successfully"

    - name: ASG instance replacement 
      run: |
        echo "Starting ASG instance replacement..."
        
        # Get current ASG configuration
        ASG_INFO=$(aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names php-app-asg \
          --region ${{ env.AWS_REGION }} \
          --query 'AutoScalingGroups[0]')
        
        CURRENT_DESIRED=$(echo $ASG_INFO | jq -r '.DesiredCapacity')
        CURRENT_MAX=$(echo $ASG_INFO | jq -r '.MaxSize')
        CURRENT_INSTANCES=$(echo $ASG_INFO | jq -r '.Instances[].InstanceId' | tr '\n' ' ')
        
        echo "Current desired capacity: $CURRENT_DESIRED"
        echo "Current instances: $CURRENT_INSTANCES"
        
        # Temporarily increase capacity to accommodate new instances
        NEW_DESIRED=$((CURRENT_DESIRED * 2))
        NEW_MAX=$((CURRENT_MAX < NEW_DESIRED ? NEW_DESIRED : CURRENT_MAX))
        
        echo "Temporarily increasing capacity to: $NEW_DESIRED (max: $NEW_MAX)"
        
        aws autoscaling update-auto-scaling-group \
          --auto-scaling-group-name php-app-asg \
          --region ${{ env.AWS_REGION }} \
          --desired-capacity $NEW_DESIRED \
          --max-size $NEW_MAX
        
        # Wait for new instances to launch and become healthy
        echo "Waiting for new instances to be healthy..."
        
        TIMEOUT=600
        ELAPSED=0
        INTERVAL=15
        
        while [ $ELAPSED -lt $TIMEOUT ]; do
          HEALTHY_COUNT=$(aws elbv2 describe-target-health \
            --target-group-arn $(aws elbv2 describe-target-groups \
              --names php-app-tg \
              --region ${{ env.AWS_REGION }} \
              --query 'TargetGroups[0].TargetGroupArn' \
              --output text) \
            --region ${{ env.AWS_REGION }} \
            --query 'length(TargetHealthDescriptions[?TargetHealth.State==`healthy`])' \
            --output text)
          
          echo "Healthy instances: $HEALTHY_COUNT (need: $NEW_DESIRED)"
          
          if [ "$HEALTHY_COUNT" -ge "$NEW_DESIRED" ]; then
            echo "All new instances are healthy!"
            break
          fi
          
          sleep $INTERVAL
          ELAPSED=$((ELAPSED + INTERVAL))
        done
        
        if [ $ELAPSED -ge $TIMEOUT ]; then
          echo "Timeout waiting for instances to be healthy, proceeding anyway..."
        fi
        
        # Terminate old instances
        echo "Terminating old instances..."
        for INSTANCE_ID in $CURRENT_INSTANCES; do
          echo "Terminating instance: $INSTANCE_ID"
          aws autoscaling terminate-instance-in-auto-scaling-group \
            --instance-id $INSTANCE_ID \
            --region ${{ env.AWS_REGION }} \
            --should-decrement-desired-capacity
        done
        
        # Wait a moment for terminations to process
        sleep 30
        
        # Restore original capacity
        echo "Restoring original capacity: $CURRENT_DESIRED"
        aws autoscaling update-auto-scaling-group \
          --auto-scaling-group-name php-app-asg \
          --region ${{ env.AWS_REGION }} \
          --desired-capacity $CURRENT_DESIRED \
          --max-size $CURRENT_MAX
        
        # Final health check
        echo "Performing final health check..."
        sleep 30
        
        FINAL_HEALTHY=$(aws elbv2 describe-target-health \
          --target-group-arn $(aws elbv2 describe-target-groups \
            --names php-app-tg \
            --region ${{ env.AWS_REGION }} \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text) \
          --region ${{ env.AWS_REGION }} \
          --query 'length(TargetHealthDescriptions[?TargetHealth.State==`healthy`])' \
          --output text)
        
        echo "Final healthy instances: $FINAL_HEALTHY (expected: $CURRENT_DESIRED)"
        
        if [ "$FINAL_HEALTHY" -ge "$CURRENT_DESIRED" ]; then
          echo "Deployment completed successfully"
        else
          echo "Warning: Not all instances are healthy, but deployment completed"
        fi

    - name: Verify deployment and run integration tests
      env:
        APP_URL: ${{ steps.outputs.outputs.app-url }}
        DB_HOST: ${{ steps.outputs.outputs.database-endpoint }}
        DB_PORT: 3306
        DB_NAME: testdb
        DB_USERNAME: ${{ secrets.DB_USERNAME }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        DISPLAY: :99
      run: |
        echo "Waiting for application at: $APP_URL"
        timeout 120 bash -c 'until curl -s "$APP_URL" | grep -q "Simple PHP Application"; do sleep 10; done'
        
        # Set up test environment
        pip install -r tests/requirements.txt
        wget -q "https://storage.googleapis.com/chrome-for-testing-public/138.0.7153.0/linux64/chromedriver-linux64.zip"
        unzip -q chromedriver-linux64.zip
        sudo mv chromedriver-linux64/chromedriver /usr/local/bin/
        
        Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
        sleep 2
        
        python -m pytest tests/ -v --tb=short --maxfail=3

    - name: Deployment summary
      if: always()
      run: |
        echo "=== DEPLOYMENT SUMMARY ==="
        echo "Stack: ${{ env.STACK_NAME }}"
        echo "Region: ${{ env.AWS_REGION }}"
        echo "Image: ${{ env.DOCKER_IMAGE_TAG }}"
        echo "Status: ${{ job.status }}"
        if [ "${{ job.status }}" = "success" ]; then
          echo "App URL: ${{ steps.outputs.outputs.app-url }}"
        fi
        echo "=========================="