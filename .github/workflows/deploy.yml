name: Deploy PHP Application

on:
  push:
    branches: [ main ]
  
env:
  AWS_REGION: eu-west-2
  STACK_NAME: php-app
  DOCKER_IMAGE_TAG: ${{ github.sha }}

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          MYSQL_DATABASE: testdb
          MYSQL_USER: testuser
          MYSQL_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping -h localhost" --health-interval=10s --health-timeout=5s --health-retries=5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-
    
    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: false
        tags: php-app:${{ env.DOCKER_IMAGE_TAG }}
        load: true
        cache-from: type=local,src=/tmp/.buildx-cache
        cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
    
    - name: Move cache
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache
    
    - name: Create Docker network
      run: docker network create test-network
    
    - name: Wait for MySQL to be ready
      run: |
        echo "Waiting for MySQL to be ready..."
        timeout 60 bash -c 'until docker exec $(docker ps -q --filter ancestor=mysql:8.0) mysqladmin ping -h localhost --silent; do 
          echo "MySQL is not ready yet..."
          sleep 2
        done'
        echo "MySQL is ready"
    
    - name: Connect MySQL to test network
      run: |
        MYSQL_CONTAINER=$(docker ps -q --filter ancestor=mysql:8.0)
        echo "Connecting MySQL container $MYSQL_CONTAINER to test-network"
        docker network connect test-network $MYSQL_CONTAINER 

    - name: Run PHP application container
      run: |
        docker run -d --name php-app --network test-network -p 8080:80 \
          -e DB_HOST=mysql \
          -e DB_USERNAME=testuser \
          -e DB_PASSWORD=${{ secrets.TEST_DB_PASSWORD }} \
          -e DB_NAME=testdb \
          -e DB_PORT=3306 \
          -e APP_ENV=testing \
          php-app:${{ env.DOCKER_IMAGE_TAG }}

        docker ps --filter name=php-app
    
    - name: Check container logs
      run: |
        echo "=== PHP Application Logs ==="
        docker logs php-app || echo "No logs yet"
        echo "=== MySQL Logs ==="
        docker logs $(docker ps -q --filter ancestor=mysql:8.0) | tail -10 || echo "No MySQL logs"
    
    - name: Test network connectivity
      run: |
        echo "Testing network connectivity..."
        # Test basic connectivity using curl from host
        docker exec php-app curl -s http://mysql:3306 || echo "Cannot connect to mysql:3306"
        
        # Check if PHP container can resolve mysql hostname
        docker exec php-app getent hosts mysql || echo "Cannot resolve mysql hostname"
        
        # Test MySQL connection from PHP container
        docker exec php-app php -r "
        try {
          \$pdo = new PDO('mysql:host=mysql;port=3306;dbname=testdb', 'testuser', '${{ secrets.TEST_DB_PASSWORD }}');
          echo 'Database connection successful\n';
        } catch (Exception \$e) {
          echo 'Database connection failed: ' . \$e->getMessage() . \"\n\";
        }
        " || echo "PHP database test failed"

    - name: Wait for application to be ready
      run: |
        echo "Waiting for application to respond..."
        timeout 180 bash -c 'until curl -s http://localhost:8080/ || curl -s http://localhost:8080/index.php; do 
          echo "App not ready yet. Checking logs..."
          docker logs php-app | tail -5
          sleep 10
        done'
        echo "Application is responding"
    
    - name: Set up Python for testing
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install Python test dependencies
      run: |
        pip install -r tests/requirements.txt
    
    - name: Run application tests
      env:
        APP_URL: http://localhost:8080
        DB_HOST: localhost
        DB_PORT: 3306
        DB_NAME: testdb
        DB_USERNAME: testuser
        DB_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
        DISPLAY: :99
      run: |
        # Start virtual display for headless Chrome
        sudo apt-get update -qq
        sudo apt-get install -y xvfb
        export DISPLAY=:99
        Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
        sleep 3

    - name: Download latest ChromeDriver
      run: |
        wget "https://storage.googleapis.com/chrome-for-testing-public/138.0.7153.0/linux64/chromedriver-linux64.zip"
        unzip chromedriver-linux64.zip
        chmod +x chromedriver
        sudo mv chromedriver /usr/local/bin/

        python -m pytest tests/ -v --tb=short
    
    - name: Run basic smoke tests
      run: |

        echo "Testing basic connectivity..."
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ || echo "000")
        echo "HTTP response code: $HTTP_CODE"

        echo "Testing different endpoints..."
        curl -s http://localhost:8080/ | head -10 || echo "Main endpoint failed"
        curl -s http://localhost:8080/index.php | head -10 || echo "index.php failed"
        curl -s http://localhost:8080/health.php | head -10 || echo "health.php failed"
        
        # Check if any endpoint returns 200
        if curl -f http://localhost:8080/ || curl -f http://localhost:8080/index.php; then
          echo "At least one endpoint is accessible"
        else
          echo "No endpoints are accessible"
          echo "=== Final container logs ==="
          docker logs php-app
          exit 1
        fi
    
    - name: Cleanup containers
      if: always()
      run: |
        docker stop php-app || true
        docker rm php-app || true
        docker network rm test-network || true

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        role-duration-seconds: 3600
    
    - name: Validate CloudFormation template
      run: |
        aws cloudformation validate-template \
          --template-body file://infrastructure/cloudformation.yaml \
          --region ${{ env.AWS_REGION }}
    
    - name: Check if stack exists
      id: check-stack
      run: |
        if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "stack-exists=true" >> $GITHUB_OUTPUT
          echo "Stack exists, will update"
        else
          echo "stack-exists=false" >> $GITHUB_OUTPUT
          echo "Stack does not exist, will create"
        fi
    
    - name: Deploy CloudFormation stack
      id: deploy-stack
      run: |
        aws cloudformation deploy \
          --template-file infrastructure/cloudformation.yaml \
          --stack-name ${{ env.STACK_NAME }} \
          --parameter-overrides \
            KeyPairName=${{ secrets.KEY_PAIR_NAME }} \
            DBUsername=${{ secrets.DB_USERNAME }} \
            DBPassword=${{ secrets.DB_PASSWORD }} \
            Environment=production \
            ImageTag=${{ env.DOCKER_IMAGE_TAG }} \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region ${{ env.AWS_REGION }} \
          --no-fail-on-empty-changeset
    
    - name: Wait for stack deployment
      run: |
        if [ "${{ steps.check-stack.outputs.stack-exists }}" = "true" ]; then
          echo "Waiting for stack update to complete..."
          aws cloudformation wait stack-update-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} || \
          aws cloudformation wait stack-update-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
        else
          echo "Waiting for stack creation to complete..."
          aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
        fi
    
    - name: Get deployment outputs
      id: get-outputs
      run: |
        STACK_OUTPUTS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs')
        
        LOAD_BALANCER_DNS=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="LoadBalancerDNS") | .OutputValue')
        APP_URL="https://${LOAD_BALANCER_DNS}"
        
        echo "app-url=${APP_URL}" >> $GITHUB_OUTPUT
        echo "load-balancer-dns=${LOAD_BALANCER_DNS}" >> $GITHUB_OUTPUT
        
        echo "Application deployed to: ${APP_URL}"
    
    - name: Wait for application to be accessible
      run: |
        echo "Waiting for application to be accessible at ${{ steps.get-outputs.outputs.app-url }}"
        timeout 600 bash -c 'until curl -k -s "${{ steps.get-outputs.outputs.app-url }}/health.php" | grep -q "OK\|healthy"; do 
          echo "Waiting for app to be accessible..."
          sleep 10
        done'
        echo "Application is accessible"
    
    - name: Run post-deployment integration tests
      env:
        APP_URL: ${{ steps.get-outputs.outputs.app-url }}
      run: |
        # Set up Python for integration tests
        pip install -r tests/requirements.txt
        
        # Run integration tests against deployed application
        python -m pytest tests/ -v --tb=short
    
    - name: Update deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "Deployment completed successfully"
          echo "Application URL: ${{ steps.get-outputs.outputs.app-url }}"
          echo "Load Balancer DNS: ${{ steps.get-outputs.outputs.load-balancer-dns }}"
        else
          echo "Deployment failed"
        fi
